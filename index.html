<!DOCTYPE html>
<meta charset="utf-8">
<head>
<style>
  body {background-color:#f7f7ed}
</style>

</head>
<body>

    <select id='glopselect'>
      <option value="geographic">geographic locations</option>
      <option value="paragraph">paragraph glop</option>
      <option value="checkerboard">checkerboard glop</option>
      <option value="scatterglop">scatterglop</option>
    </select>

<script src="js/vendor/d3.v3.min.js"></script>
<script src="js/vendor/topojson.v1.min.js"></script>

<script>

var mouseovercolor = "#5c694a",
    defaultcolor = "#dce9ca";

var w = window,
    d = document,
    e = d.documentElement,
    g = d.getElementsByTagName('body')[0],
    x = w.innerWidth || e.clientWidth || g.clientWidth,
    y = w.innerHeight|| e.clientHeight|| g.clientHeight;

var margin = 50;

var width = x - margin,
    height = y - margin;

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .attr("preserveAspectRatio", "meet xMidYMid");

var glopvalues = [];
var shapes;

var drawbboxes = false; // set to true to just draw bounding boxes, false to draw shapes
var rescaleshapes = true; // set to true to rescale shapes proportionally

//var glopStyle = 'paragraph';
//var glopStyle = 'checkerboard';
//var glopStyle = 'scatterglop';
var glopStyle = 'geographic';

// Settings and functions for the checkerboard glop
//var numcolumns = 10;
//var gridsize = (width - 2 * margin) / numcolumns;
var gridsize = 100;
var numcolumns = Math.floor(width/gridsize);

function xpos(rank) {
  //console.log("rank:", rank, ", xpos: ", rank % numcolumns);
  return 1 + rank % numcolumns;
}

function ypos(rank) {
  //console.log("rank:", rank, ", ypos: ", Math.floor(rank/numcolumns));
  return 1 + Math.floor(rank/numcolumns);
}

// Scales for the scatterglop
var xscale, yscale;

// For resizing shapes to be similar sizes

var resizeScale;

// Projection settings
// modifying a projection from http://bost.ocks.org/mike/map/.
var projection = d3.geo.albers()
    .center([0,36]) // For statewide view
    .rotate([119, 0]) // For statewide view
    .parallels([32,40])
    .scale(5000) // 5000 For statewide view
    .translate([width / 2, height / 2]);

var path = d3.geo.path().projection(projection);

//d3.json("data/cpad19_superunits.topojson", function(error, units) {
d3.json("data/cpad19_superunits_nps.topojson", function(error, units) {
    //console.log(units);


    shapes = svg.selectAll("path")
        .data(topojson.feature(units, units.objects.cpad19_superunits_nps).features)
        //.data(topojson.feature(units, units.objects.cpad19_superunits).features)
      .enter().append("path")
        .attr("d", drawbboxes 
                    ?
                      function(d) { var b = d3.geo.path().projection(projection).bounds(d); return "M" + [b[0] + "H" + b[1][0] + "V" + b[1][1] + "H" + b[0][0]] + "Z"; } // Bounding boxes from http://bl.ocks.org/mbostock/4431123
                    :
                      path)

        .each(function(d, i) {
          //console.log(d.properties.unit_name, path.area(d));
          glopvalues[i] = +path.area(d);
        });

    // Use slice to make a copy to avoid sorting the original array:
    gloprank = d3.scale.ordinal()
        .domain(glopvalues.slice(0).sort(function(a, b) { return a > b ? -1 : a < b ? 1 : 0; }))
        .rangePoints([0, glopvalues.length - 1])

    // For use as a scatterglop
    xscale = d3.scale.linear()
        .domain([d3.min(glopvalues),d3.max(glopvalues)])
        .range([margin, width-2*margin]);

    yscale = d3.scale.linear()
        .domain([d3.min(glopvalues),d3.max(glopvalues)])
        .range([margin, height-2*margin]);

    var largestAxes = [];
    shapes
        .attr("fill",defaultcolor)
        //.attr("opacity",0.9)
        .on("mouseover", function(d, i) { 
          console.log(d.properties.unit_name + " " + d.properties.agncy_id + " index: " + i + " area: " + path.area(d) + " rank: " + gloprank(path.area(d)));
          d3.select(this).style("fill",mouseovercolor);
        })
        .on("mouseout", function(d, i) {
          d3.select(this).style("fill",defaultcolor);
        })
        .each(function(d,i) {
          var bbox = this.getBBox();
          var curwidth = bbox.width;
          var curheight = bbox.height;
          largestAxes.push(curwidth > curheight ? curwidth : curheight);
        });

    resizeScale = d3.scale.linear()
        .domain([d3.min(largestAxes),d3.max(largestAxes)])
        .range([50,200]);

    sortGlop(glopStyle);

    console.log("done!");
});

function sortGlop(sortType) {
    // Reset variables for the paragraph glop
    var currentBaseX = margin;
    var currentBaseY = margin;
    var nextBaseY = currentBaseY;

    shapes
        .sort(function(a,b) { return path.area(a) > path.area(b) ? -1 : path.area(a) < path.area(b) ? 1 : 0; })
        .transition()
        .duration(2000)
        .attr("transform", function(d, i) {
            var bbox = this.getBBox();

            var x0 = bbox.x;
            var y0 = bbox.y;
            var curwidth = bbox.width;
            var curheight = bbox.height;
            var curX = bbox.x + bbox.width/2;
            var curY = bbox.y + bbox.height/2;

            var scaleFactor = 1;
            if (rescaleshapes && sortType != 'geographic') {
              var largestaxis = curwidth > curheight ? curwidth : curheight;
              scaleFactor = resizeScale(largestaxis) / largestaxis;
            }
            var scalestr = "scale(" + scaleFactor + ")";

            //if (sortType == 'geographic')
            var resetx = curX;
            var resety = curY;
            var transvalx = curX;
            var transvaly = curY;

            if (sortType == 'checkerboard') {
              resetx = curX;
              resety = curY;
              transvalx = xpos(gloprank(path.area(d))) * gridsize;
              transvaly = ypos(gloprank(path.area(d))) * gridsize;
            }

            if (sortType == 'scatterglop') {
              resetx = curX;
              resety = curY;
              transvalx = margin + xscale(path.area(d)) - curwidth/2;
              transvaly = margin + yscale(path.area(d)) - curheight/2;
            }

            if (sortType == 'paragraph') {
              //console.log("    currentBaseX:", currentBaseX, "    currentBaseY:", currentBaseY, "    nextBaseY:", nextBaseY);
              resetx = x0;
              resety = y0;
              transvalx = currentBaseX;
              // This tests if we've hit the edge of the page, and starts a new line if so.
              if ((transvalx + (curwidth*scaleFactor)) > (width - margin)) {
                //console.log("index:", i, "new line");
                currentBaseX = margin;
                transvalx = currentBaseX;
                currentBaseY = nextBaseY;
                nextBaseY = margin;
              }
              currentBaseX += curwidth*scaleFactor;
              transvaly = currentBaseY;
              // This tests if our next line needs to be moved down
              if (nextBaseY < (currentBaseY + (curheight*scaleFactor))) {
                nextBaseY = currentBaseY + (curheight*scaleFactor);
                //console.log(d.properties.unit_name, "index:", i, "rank:", gloprank(path.area(d)), "extending next height to:", nextBaseY);
              }
              //console.log("new currentBaseX:", currentBaseX, "new currentBaseY:", currentBaseY, "new nextBaseY:", nextBaseY);
            }

            //console.log("index:", i, "area:", path.area(d), "rank:", gloprank(path.area(d)));
            //console.log("index:", i, "original center:", (x1 + x0)/2, ",", (y1 + y0)/2);
            //console.log("index:", i, "new center:", xpos(gloprank(path.area(d))) * gridsize, ",", ypos(gloprank(path.area(d))) * gridsize);
            //console.log("index:", i, "translate:", transvalx, ",", transvaly);

            //console.log(d.properties.unit_name, "scaleFactor", scaleFactor, "transvalx", transvalx, "transvaly", transvaly, "curX", curX, "curY", curY);
            var transstr = "translate(" + -resetx*(scaleFactor-1)  + "," + -resety*(scaleFactor-1) + ")" + scalestr + "translate(" + ((transvalx-resetx)/(scaleFactor))  + "," + ((transvaly-resety)/(scaleFactor)) + ")";
            //console.log(transstr);
            return transstr;
        });


}

d3.select("#glopselect").on("change", function(e) {
  sortGlop(this.value);
});

</script>
</body>
</html>