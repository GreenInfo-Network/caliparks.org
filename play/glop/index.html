<!DOCTYPE html>
<meta charset="utf-8">
<body>

    <select id='glopselect'>
      <option value="geographic">geographic locations</option>
      <option value="paragraph">paragraph glop</option>
      <option value="checkerboard">checkerboard glop</option>
      <option value="scatterglop">scatterglop</option>
    </select>

<script src="js/vendor/d3.v3.min.js"></script>
<script src="js/vendor/topojson.v1.min.js"></script>

<script>

var w = window,
    d = document,
    e = d.documentElement,
    g = d.getElementsByTagName('body')[0],
    x = w.innerWidth || e.clientWidth || g.clientWidth,
    y = w.innerHeight|| e.clientHeight|| g.clientHeight;

var margin = 50;

var width = x - margin,
    height = y - margin;

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var glopvalues = [];
var shapes;

var drawbboxes = false; // set to true to just draw bounding boxes

//var glopStyle = 'paragraph';
//var glopStyle = 'checkerboard';  // default
//var glopStyle = 'scatterglop';
var glopStyle = 'geographic';

// Settings and functions for the checkerboard glop
//var numcolumns = 10;
//var gridsize = (width - 2 * margin) / numcolumns;
var gridsize = 300;
var numcolumns = Math.floor(width/gridsize);

function xpos(rank) {
  //console.log("rank:", rank, ", xpos: ", rank % numcolumns);
  return 1 + rank % numcolumns;
}

function ypos(rank) {
  //console.log("rank:", rank, ", ypos: ", Math.floor(rank/numcolumns));
  return 1 + Math.floor(rank/numcolumns);
}

// Settings and variables for the paragraph glop

var currentBaseX = margin;
var currentBaseY = margin;
var nextBaseY = currentBaseY;

var xscale, yscale;

// Projection settings
// modifying a projection from http://bost.ocks.org/mike/map/.
var projection = d3.geo.albers()
    //.center([0,37.34]) // For St. James Park in San Jose
    //.rotate([121.89, 0]) // For St. James Park in San Jose
    .center([0,36]) // For statewide view
    .rotate([119, 0]) // For statewide view
    .parallels([32,40])
    //.scale(5000000) // For St. James Park in San Jose
    .scale(20000) // 5000 For statewide view
    .translate([width / 2, height / 2]);

var path = d3.geo.path().projection(projection);

//d3.json("st_james_park.topojson", function(error, units) {
//d3.json("cpad19_superunits.topojson", function(error, units) {
d3.json("cpad19_superunits_nps.topojson", function(error, units) {
    //console.log(units);


    shapes = svg.selectAll("path")
        .data(topojson.feature(units, units.objects.cpad19_superunits_nps).features)
        //.data(topojson.feature(units, units.objects.cpad19_superunits).features)
        //.data(topojson.feature(units, units.objects.st_james_park).features)
      .enter().append("path")
        .attr("d", drawbboxes 
                    ?
                      function(d) { var b = d3.geo.path().projection(projection).bounds(d); return "M" + [b[0] + "H" + b[1][0] + "V" + b[1][1] + "H" + b[0][0]] + "Z"; } // Bounding boxes from http://bl.ocks.org/mbostock/4431123
                    :
                      path)

        .each(function(d, i) {
          //console.log(d.properties.unit_name, path.area(d));
          glopvalues[i] = +path.area(d);
        });

    // Use slice to make a copy to avoid sorting the original array:
    gloprank = d3.scale.ordinal()
        .domain(glopvalues.slice(0).sort(function(a, b) { return a > b ? -1 : a < b ? 1 : 0; }))
        .rangePoints([0, glopvalues.length - 1])

    // For use as a scatterglop
    xscale = d3.scale.linear()
        .domain([d3.min(glopvalues),d3.max(glopvalues)])
        .range([margin, width-2*margin]);

    yscale = d3.scale.linear()
        .domain([d3.min(glopvalues),d3.max(glopvalues)])
        .range([margin, height-2*margin]);

    shapes
        .attr("fill","#aaa")
        .attr("stroke","#fff")
        .attr("opacity",0.5)
        .attr("stroke-opacity",0.5)
        .on("mouseover", function(d, i) { 
          console.log(d.properties.unit_name + " " + d.properties.agncy_id + " index: " + i + " area: " + path.area(d) + " rank: " + gloprank(path.area(d)));
          d3.select(this).style("fill","#0f0");
        })
        .on("mouseout", function(d, i) {
          d3.select(this).style("fill","#aaa");
        })
        .each(function(d,i) {
          d3.select(this).original_x = projection(d3.geo.bounds(d)[0])[0] - projection(d3.geo.bounds(d)[1])[0];
          d3.select(this).original_y = projection(d3.geo.bounds(d)[0])[1] - projection(d3.geo.bounds(d)[1])[1];
        });

    sortGlop(glopStyle);

    console.log("done!");
});

function sortGlop(sortType) {
    shapes
        .sort(function(a,b) { return path.area(a) > path.area(b) ? -1 : path.area(a) < path.area(b) ? 1 : 0; })
        .transition()
        .duration(2000)
        .attr("transform", function(d, i) {
            var bounds = d3.geo.bounds(d);
            var lowerleft = projection(bounds[0]);
            var upperright = projection(bounds[1]);
            var x0 = lowerleft[0];
            var y0 = lowerleft[1];
            var x1 = upperright[0];
            var y1 = upperright[1];
            var curwidth = x1 - x0;
            var curheight = y0 - y1;

            // for checkerboard glop:
            var transvalx = xpos(gloprank(path.area(d))) * gridsize - (x1 + x0)/2;
            var transvaly = ypos(gloprank(path.area(d))) * gridsize - (y1 + y0)/2;

            if (sortType == 'scatterglop') {
              var transvalx = margin + xscale(path.area(d)) - (x1 + x0)/2 - curwidth/2;
              var transvaly = margin + yscale(path.area(d)) - (y1 + y0)/2 - curheight/2;
            }

            if (sortType == 'geographic') {
              var transvalx = function(d) {return d.original_x; };
              var transvaly = function(d) {return d.original_y; };
            }

            if (sortType == 'paragraph') {
              //console.log("    currentBaseX:", currentBaseX, "    currentBaseY:", currentBaseY, "    nextBaseY:", nextBaseY);
              var transvalx = currentBaseX - x0;
              if ((transvalx + curwidth) > (width - margin)) {
                //console.log("index:", i, "new line");
                currentBaseX = margin;
                transvalx = currentBaseX - x0;
                currentBaseY += nextBaseY;
              }
              currentBaseX += curwidth;
              var transvaly = currentBaseY - y1;
              if (nextBaseY < (currentBaseY + curheight)) {
                //console.log("index:", i, "extending next height");
                nextBaseY = currentBaseY + curheight;
              }
              //console.log("new currentBaseX:", currentBaseX, "new currentBaseY:", currentBaseY, "new nextBaseY:", nextBaseY);
            }

            //console.log("index:", i, "area:", path.area(d), "rank:", gloprank(path.area(d)));
            //console.log("index:", i, "original center:", (x1 + x0)/2, ",", (y1 + y0)/2);
            //console.log("index:", i, "new center:", xpos(gloprank(path.area(d))) * gridsize, ",", ypos(gloprank(path.area(d))) * gridsize);
            //console.log("index:", i, "translate:", transvalx, ",", transvaly);

            return "translate(" + transvalx  + "," + transvaly + ")";
        });

}

d3.select("#glopselect").on("change", function(e) {
  sortGlop(this.value);
});

</script>